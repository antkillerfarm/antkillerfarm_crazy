sprinf
int32u fw_sprintf(int8u *buffer, const int8u *format, ...)
未实现的功能：
1..浮点数%e和%g

缺陷修改：
1.浮点数格式化的时候，需要使用FCP将浮点数转化为整数，从而得到浮点数的整数部分，但是这个转换是有定义域限制的，整数部分的绝对值不能超过2^63，在实际使用中，我们格式化输出的最大数值就是伪距，一般也就在1e8以内。所以在这里，我们将限制格式化浮点数的大小，这个门限现定为2^31-1，超出范围的数，输出字符串“TOL”（TOo Large）。这可以有效防止程序在soc上运行时的死机。
2.添加对%s打印字符串的支持.
3.修改
#define MAX_BUF_LEN 256
为
#define MAX_BUF_LEN 2048
以满足现在对字符串处理越来越长的要求。
4.添加对%u打印无符号整数的支持
-------------------------------------------------
scanf
int32u fw_sscanf(int8u *buffer, const int8u *format, ...)

format中的一个匹配模式的格式为：
%[*] [width] [{ h | l | b}] type

*（ANSI）
解析但不赋值。
例如
	strcpy((char *)buf, "Ff,-111#ggggg^123@-123456789");
	fw_sscanf(buf,(int8u *)"%x,%d#%5s^%*d@%ld",
				&i2,
				&i7,
				buf1,
				&i6
				);
buf中第4个字段“123”会被解析成%d，但由于有“*”的存在，表明这个字段在变参表中没有对应的项目，因此不会做赋值操作。变参表中的第4个参数i6，顺延对应buf的第5个字段“-123456789”。

width（和ANSI定义一致，但用法有差异，差异如下：）
仅在字符串操作时有效，其他时候忽略之。

h（ANSI）
针对16位整数

l（和ANSI定义不完全相同，ANSI定义该符号为long类型，但long类型的字长和机器/编译器类型有关）
针对64位整数

b（自定义）
针对8位整数

type包括以下几种：
s（ANSI）
字符串。必须指定width，否则工作异常。源字符串在当前位置以后的字符数以及目标字符串缓冲区的大小至少为width+1。由于只是简单的内存复制操作，因此对源字符串中当前位置以后的width宽度内的字符没有任何限制，使用时需要小心利用这个特性。

c（ANSI）
单个字符。处理和字符串相同，均为简单的内存复制操作。

d（ANSI）
有符号10进制整数。

x（ANSI）
无符号的16进制整数。支持A～F使用大小写或者混合大小写。

f（未实现，但保留，不可用作匹配模式之间的分隔符的首个字符）
双精度浮点数

返回值
与ANSI相同的部分：
返回解析并赋值成功的参数的个数，也就是说以*标识的匹配模式的结果将不计入其中。
与ANSI不同的部分：
没有针对其他类型错误的相关定义。

注意事项：
1.由于是个简化实现（在Andes上的代码尺寸为2.6K，标准库相同函数在Andes上的代码尺寸为15.4K），因此缺少严格的语法分析，在使用时必须严格按照要求定义format字符串。
2.一个匹配模式以%开始，以不在匹配模式中出现的任意字符为结尾，因此数字、*、l、h、b、s、c、d、x、f均不可作为匹配模式之间的分隔符的首个字符。但分隔符的第二个（及以后的）字符则没有这个限制。%不可出现在分隔符的任意字符中。
3.需要根据被赋值的参数的位宽，仔细选择位宽修饰符，否则会在赋值的时候产生问题。
4.程序不会对数字是否超过相应位宽的表示范围做任何检查，需由调用者自己保证不会出问题。
5.需要根据返回值来判断相关的赋值操作是否已经成功。
